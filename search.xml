<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My first blog</title>
    <url>/2021/10/24/My-first-blog/</url>
    <content><![CDATA[<p>恍恍惚惚，现在都大二了，我开始意识到了对于学计算机的，写博客是多么的重要，于是就有了这个网站，希望能和大家一起学习。</p>
]]></content>
      <categories>
        <category>通知</category>
      </categories>
      <tags>
        <tag>notice</tag>
      </tags>
  </entry>
  <entry>
    <title>取数组合——判断素数</title>
    <url>/2021/11/07/N%E4%B8%AA%E6%95%B0%E4%B8%AD%E5%8F%96k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>马上ACM要考核了，我也开始复习我在OJ上做过的门槛题，看到了这个挺难的题，说实话，当时我没写出来这道题，我还是去社区搜了一下才找到解法的，要用到DFS，属于数据结构图论里面的算法，确实比较难。</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>组长特别想让小学妹进组，但是现在在所有新生中有一些是假扮的小学妹，为了知道那些是真正的小学妹，组长想到了一个好办法：<br><strong>已知n个整数b1,b2,…,bn,他们分别代表所有的新生,以及一个整数k（k＜n）。</strong><br><strong>从n个整数中任选k个整数相加，可分别得到一系列的和。</strong><br>例如当n=4，k＝3，4个整数分别为3，7，12，19时，可得全部的组合与它们的和为：<br>3＋7＋12=22，3＋7＋19＝29，7＋12＋19＝38，3＋12＋19＝34。<br>只有当他们的和是素数的时候，他们的真实身份才会显现，你的任务就是算出一共有几组满足条件的组合。<br>例如上例，只有一种组合为素数：3＋7＋19＝29。</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数：n , k 。（1&lt;=n&lt;=20，k＜n）<br>第二行n个整数：x1,x2，…,xn 。（1&lt;=xi&lt;=5000000）</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数（满足条件的方案数）。</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h3><pre><code class="c++">4 3
3 7 12 19
</code></pre>
<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h3><pre><code class="c++">1
</code></pre>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>由于N和K都是不确定的，所以我们没法写出具体多少个循环来算，只能用递归。每递归一次，参数K就减小1，当K等于0时，判断sum的值是否为素数，是的话答案加1。思路其实就是这样，看起来简单，但理清并写出来确实有点难，但我相信聪明的你看完我的源码后能自己写出来。</p>
<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
using namespace std;
int count=0;//输出的答案
//判断n是否是素数，应该都写过很多次了，就不解释了
int judge(int n)&#123;
    int m=sqrt(n);
    for(int i=2;i&lt;=m;i++)&#123;
        if(n%i==0)&#123;
            return 0;//否
        &#125;
    &#125;
    return 1;//是
&#125;
//递归体，使用了DFS的思路
void opera(int *num,int n/*总数*/,int k/*取K个数*/,int sum/*所求和*/,int s/*开始处*/)&#123;
    if(k==0)&#123;//即已经取出了k个数并求和
        if(judge(sum))&#123;
            count++;
            return ;
        &#125;
    &#125;
    else&#123;
        int i;
        for(i=s;i&lt;n;++i)&#123;//从开始依次处取数
            opera(num,n,k-1,sum+num[i],i+1);
        &#125;
    &#125;
&#125;
//主函数
int main()&#123;
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    int num[n];
    for(int i=0;i&lt;n;i++)&#123;
        cin&gt;&gt;num[i];
    &#125;
    opera(num,n,k,0,0);
    cout&lt;&lt;count&lt;&lt;endl;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>difficult</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/10/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>关于BFS的例题</title>
    <url>/2021/10/25/%E5%85%B3%E4%BA%8EBFS%E7%9A%84%E4%BE%8B%E9%A2%98/</url>
    <content><![CDATA[<p>题名：银老板家的电梯</p>
<p>题目描述</p>
<p>众所周知银老板是喀兰贸易的老大，银老板家也很有钱，上下楼都要用电梯，但是电梯里面没有按钮，电梯外面有上和下，按上你就会上升mi层，按下你就会下降mi层，即到达i+mi层或者i-mi层，i是你的当前楼层。现在银老板在p层，他想要去t层，请你帮帮银老板他最少需要按多少下按钮可以到达目的地。说不定他就来到你岛了呢？如果你还没有理解题意的话好吧我就举个例子：比如银老板在第2层，想要去第5层，且m依次为4,1,2,3,4;则他最少需要按2次（连续按2次上或者先按1次下再按1次上）才能到达目的地。（楼层&gt;=1）</p>
<p>输入<br>第一行一个n,p,t（1&lt;=n,p,t&lt;=200）</p>
<p>第二行n个整数m1,m2…….mn;（0&lt;=mi&lt;=50）</p>
<p>输出<br>一个整数表示从p层到t层最少需要按多少次。如果不能到达输出-1。</p>
<p>输入样例 1<br>5 2 5<br>4 1 2 3 4</p>
<p>输出样例 1<br>2</p>
<p>输入样例 2<br>6 3 2<br>1 2 3 4 5 6</p>
<p>输出样例 2<br>-1</p>
<p>解题思路</p>
<p>根据题意可知，每层楼对应的下一层选项最多有两个，所以我们采用二维数组来存储每一层的一些信息。再来采用BFS算法，在使用BFS算法时我们需要一个队列，对于已经入队的楼层，我们先检查它是否是我们要达到的楼层，若不是则出列，并且将它的下一层入队，是则直接输出该楼层的循环次数。</p>
<p>源码</p>
<p>#include<iostream><br>#include<algorithm><br>#include<queue><br>#include<cstring><br>using namespace std;<br>const int MAXSIZE=201;<br>int n,s,e;<br>int floor[MAXSIZE][2];<br>struct info{<br>    int pos;<br>    int time;<br>};<br>queue<info> q;<br>int path(){<br>    info now,next,tmp;<br>    tmp.pos=s;<br>    tmp.time=0;<br>    q.push(tmp);<br>    if(s&lt;1||s&gt;MAXSIZE||e&lt;1||e&gt;MAXSIZE){<br>        return -1;<br>    }<br>    while(!q.empty()){<br>        now=q.front();<br>        if(now.pos==e){<br>            return now.time;<br>        }<br>        q.pop();<br>        int up=floor[now.pos][0];<br>        int down=floor[now.pos][1];<br>        if(up!=-1){<br>            next.pos=up;<br>            next.time=now.time+1;<br>            q.push(next);<br>        }<br>        if(down!=-1){<br>            next.pos=down;<br>            next.time=now.time+1;<br>            q.push(next);<br>        }<br>    }<br>    return -1;<br>}<br>int main(){<br>    cin&gt;&gt;n;<br>    memset(floor,-1,sizeof(floor));<br>    cin&gt;&gt;s&gt;&gt;e;<br>    for(int i=1;i&lt;=n;i++){<br>        int t;<br>        cin&gt;&gt;t;<br>        if(i+t&lt;=n){<br>            floor[i][0]=i+t;<br>        }<br>        if(i-t&gt;0){<br>            floor[i][1]=i-t;<br>        }<br>    }<br>    cout&lt;&lt;path();<br>}</p>
<p>问题</p>
<p>由于我是用结构体作为队列的元素，导致我代码的空间复杂度很高，在oj上跑的时候占用空间超出范围了，不让我过。于是我又换了一种思路。</p>
<p>解题思路</p>
<p>现在我只用一个一维数组来存储信息，数组下标代表层数，对应下标所指的数代表它与下一层的差，然后再用一个同样大小的布尔类型一维数组来存储我是否已经到过这了，其他判断条件和第一次类似。</p>
<p>源码</p>
<p>#include<iostream><br>#include<algorithm><br>using namespace std;<br>const int N=220;<br>int num[N];<br>bool re[N];<br>int n,b=99999,a=0,p,t;<br>void go(int k,int a)<br>{<br>    if(k==t) b=a;<br>if(a&gt;=b) return;<br>if(!re[k+num[k]]&amp;&amp;k+num[k]&lt;=n) {<br>    re[k+num[k]]=true;<br>    a++;<br>    go(k+num[k],a);<br>    a–;<br>    re[k+num[k]]=false;<br>}</p>
<p>if(!re[k-num[k]]&amp;&amp;k-num[k]&gt;0) {<br>    re[k-num[k]]=true;<br>    a++;<br>    go(k-num[k],a);<br>    re[k-num[k]]=false;<br>a–;<br>}</p>
<p>}<br>int main()<br>{<br>    cin&gt;&gt;n&gt;&gt;p&gt;&gt;t;<br>    for(int i=1;i&lt;=n;i++)<br>    cin&gt;&gt;num[i];<br>    re[p]=true;<br>    go(p,0);<br>    if(b==99999)<br>     cout&lt;&lt;-1&lt;&lt;endl;<br>  else<br>      cout&lt;&lt;b&lt;&lt;endl;<br>}</p>
<p>这是正解。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>common</tag>
      </tags>
  </entry>
  <entry>
    <title>进制转换函数 itoa() 详解</title>
    <url>/2021/10/28/itoa()%E5%87%BD%E6%95%B0%E5%88%97%E9%A2%98/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>昨晚深夜忽有一人问我一道题怎么写，是道进制转换的题，一开始我以为很简单，但这道题还是花了我一个小时的时间，而且大部分时间都花在了对于c语言itoa()函数的误解。<br>由该函数的参数列表可知(该函数的定义可以在stdlib.h文件中找到)</p>
<pre><code class="c">char *__cdecl itoa(int _Val,char *_DstBuf,int _Radix) __MINGW_ATTRIB_DEPRECATED_MSVC2005;
</code></pre>
<p>该函数可以把一个任意的十进制数转换为任意进制的字符串。而且经过debug我发现这个字符串的存储是从高位到低位。而这和下面题目要实现的目标不相符。因为55经过转换后会变成110111，而不是00000000000000000000000000110111 ，所以我们需要对这个字符串进行移位，使其从低地址到高地址排列。而这一部还是很好实现的，只需要写个循环。当一切准备就绪时，我以为我完成了，但没想到啊，-55的转换结果和目标大相径庭，于是我又debug了一次，发现了原因： <strong>itoa()函数最终是通过补码的形式存储结果</strong>。但我以为是用源码存储所以我错了，但知道了这个特性后我很快就写出来了正解，但由于我忘了IEEE754浮点数是啥，所以没写这部分。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>32位机器数，输入一个十进制数，转换为二进制数，显示其原码、反码、补码、移码及IEEE754浮点数。</p>
<p>input 1:</p>
<p>55</p>
<p>output 1:</p>
<p>原码:00000000000000000000000000110111<br>反码:00000000000000000000000000110111<br>补码:00000000000000000000000000110111<br>移码:10000000000000000000000000110111<br>IEEE754浮点数: 01000010010111000000000000000000</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
int main()&#123;
    int a,flag,tmp;
    scanf(&quot;%d&quot;,&amp;flag);
    a=(int)abs(flag);
    char b[33],c[33],d[33],e[33],t[33];
    itoa(a,t,2);
    for(int i=0;i&lt;33;i++)&#123;
        if(t[i]==&#39;\0&#39;)&#123;
            tmp=i;
            break;
        &#125;
    &#125;
    for(int i=0;i&lt;33;i++)&#123;
        b[i]=&#39;0&#39;;
    &#125;
    for(int i=tmp;i&gt;=0;i--)&#123;
        b[32-tmp+i]=t[i];
    &#125;
    if(flag&gt;=0)&#123;
        for(int i=0;i&lt;33;i++)&#123;
            c[i]=b[i];
            d[i]=b[i];
            e[i]=b[i];
        &#125;
        e[0]=&#39;1&#39;;
    &#125;else&#123;
        itoa(flag,d,2);
        b[0]=&#39;1&#39;;
        for(int i=1;i&lt;32;i++)&#123;
            if(b[i]==&#39;0&#39;)&#123;
                c[i]=&#39;1&#39;;
            &#125;else&#123;
                c[i]=&#39;0&#39;;
            &#125;
        &#125;
        c[0]=&#39;1&#39;;c[32]=&#39;\0&#39;;
        for(int i=1;i&lt;32;i++)&#123;
            e[i]=d[i];
        &#125;
        e[0]=&#39;0&#39;;e[32]=&#39;\0&#39;;
    &#125;
    printf(&quot;%s\n%s\n%s\n%s&quot;,b,c,d,e);
    return 0;
    
&#125;
</code></pre>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>分类与标签功能已开启</title>
    <url>/2021/11/01/%E5%88%86%E7%B1%BB%E4%B8%8E%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>通知</category>
      </categories>
      <tags>
        <tag>notice</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论--矩形内画圆</title>
    <url>/2021/10/27/%E5%8D%9A%E5%BC%88%E8%AE%BA--%E7%9F%A9%E5%BD%A2%E5%86%85%E7%94%BB%E7%94%BB%E5%9C%86/</url>
    <content><![CDATA[<p>上个月我在写acm的题时，碰到了这么一道题，直到昨天我才把它解出来。</p>
<h1 id="题名：赢不了的谢强富"><a href="#题名：赢不了的谢强富" class="headerlink" title="题名：赢不了的谢强富"></a>题名：赢不了的谢强富</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>​        某天，谢强富在慕课上看了两个人玩游戏，谢强富对这个游戏很感兴趣，所以他立马拉上了志强一起玩这个游戏。游戏规则如下：首先两个人在一张纸上画了一个长宽分别为A,B的严格的矩形，然后两人依次画半径为R的圆，两人画的圆可以相切但是绝对不允许相交，当其中某一个人无法画出圆的时候，他就输了。谢强富和志强都很聪明。谢强富要首先画圆，但是玩了很多次，谢强富发现自己输多赢少，他想请问你，什么时候他能赢。</p>
<p>Input</p>
<p>第一行输入n，代表有n组测试样例。</p>
<p>每一组测试样例输入矩形的长：A，宽：B，和圆的半径：R。</p>
<p>Output</p>
<p>对于每一组测试样例，如果谢强富能赢输出YES,否则输出NO。</p>
<p>Sample Input 1 </p>
<pre><code>2
4 5 6
5 5 2
</code></pre>
<p>Sample Output 1</p>
<pre><code class="c++">NO
YES
</code></pre>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>​        其实我刚开始拿到这道题时我也很懵，似乎对于每一个案例的解法都是不一样的，而圆的最优位置也无从得知，反正就是想方设法让对手画不下去。<br>​        但片刻思考过后我们都应知道，第一个圆一定是画在矩形的正中心，这样其他空间的最大空白处就是除圆以外的矩形的四个角，而四个角能不能画下另一个圆似乎就要再次计算了，而且计算过程好像还挺复杂的，如果能画下，那别的三个角都能画下了，然后继续计算，角上的圆之间似乎又会产生空隙，我们继续计算最大的空隙是否能再画圆，而且这次的计算过程似乎还和上次不一样，也更复杂了。<br>这样就导致我们对于解题的整体思路不够清晰，写不出来代码。<br>​        上述方法其实是个误区，我们应该这样想，假如A先画，如果能画下去，那么会有四个空位，四个空位如果不能继续画下去，那A就赢了，如果能画下去，那么画的顺序将是B，A，B，A，意思就是如果B能画，那么A也能画，然后还是B画，B又要在剩下的空间里画，如果B能画，由于空间是对称的，所以会有2N的空位画，这样A还是最后画，如此循环，发现最后B肯定会有画不下去的时候。<br>​        所以我们得出结论只要先手的人能画下第一个圆，那么他就已经赢了。</p>
<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
int main()&#123;
    int n,a,b,r;
    cin&gt;&gt;n;
    while(n--)&#123;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;r;
        if(2*r&lt;=a&amp;&amp;2*r&lt;=b)&#123;
            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
        &#125;else&#123;
            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="心得："><a href="#心得：" class="headerlink" title="心得："></a>心得：</h2><p>莽做题，莽计算是会浪费很多时间的，找到规律，问题就迎刃而解了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/QshuRyaoF/MyPictureBed@master/img/%E8%A1%8C%E6%94%BF.jpg" alt="行政"></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>common</tag>
      </tags>
  </entry>
  <entry>
    <title>头歌 数据结构 实训四——串</title>
    <url>/2021/11/01/%E5%A4%B4%E6%AD%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%AE%AD%E5%9B%9B/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>花了20分钟作业写的三道题，没什么难度可言，这里就不详细解答了，<strong>只给出要求填写的函数代码</strong>(其中的乱码是中文，可以是编译格式问题导致的，不影响代码)。</p>
<h3 id="第一关：求子串"><a href="#第一关：求子串" class="headerlink" title="第一关：求子串"></a>第一关：求子串</h3><pre><code class="c++">void SubStr(SString t, SString s,int i,int len)
//从s的第i个字符开始截取长度为len的子串存入t中。
//其中1≦i≦串s的长度, 0≦len≦ 串s的长度-i+1。
//若i和len超出取值范围，则输出&quot;error&quot;；否则输出子串t。
&#123;
    // 请在这里补充代码，完成本关任务
    /********** Begin *********/
    int j=0;
    if(i&lt;1||i&gt;s[0]||len&lt;0||len&gt;s[0]-i+1)&#123;
        printf(&quot;error\n&quot;); 
    &#125;else if(len==0)&#123;
        printf(&quot;&quot;);
    &#125;else&#123;
        for(j=i;j&lt;i+len;j++)&#123;
            t[j-i]=s[j];
        &#125;
        t[j+1]=&#39;\0&#39;;
        printf(&quot;%s&quot;,t);
    &#125;
    /********** End **********/
&#125;
</code></pre>
<h3 id="第二关：串的模式匹配之简单算法"><a href="#第二关：串的模式匹配之简单算法" class="headerlink" title="第二关：串的模式匹配之简单算法"></a>第二关：串的模式匹配之简单算法</h3><pre><code class="c++">int StrIndex_BF(SString s, SString t, int pos)
//´ÓÖ÷´®sµÄµÚpos¸ö×Ö·û¿ªÊ¼²éÕÒ×Ó´®t¡£
//ÈôÕÒµ½£¬Ôò·µ»Ø×Ó´®tÔÚÖ÷´®sÖÐµÚÒ»´Î³öÏÖµÄÎ»ÖÃ£¬·ñÔò·µ»Ø0¡£
&#123;
    // ÇëÔÚÕâÀï²¹³ä´úÂë£¬Íê³É±¾¹ØÈÎÎñ
    /********** Begin *********/
    int m=s[0];int n=t[0];
    char tmp=s[1];
    for(int i=1;i&lt;=m-n;i++)&#123;
        for(int j=0;j&lt;n;j++)&#123;
            if(s[i+j]!=t[j+1])&#123;
                break;
            &#125;else&#123;
                if(j==n-1)&#123;
                    return i;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
    /********** End **********/
&#125;
</code></pre>
<h3 id="第三关：串的模式匹配之KMP算法"><a href="#第三关：串的模式匹配之KMP算法" class="headerlink" title="第三关：串的模式匹配之KMP算法"></a>第三关：串的模式匹配之KMP算法</h3><pre><code class="c++">void GetNext(SString t, int next[])
//ÇóÄ£Ê½´®TµÄnextÖµ²¢´æÈënextÊý×éÖÐ
&#123;
    // ÇëÔÚÕâÀï²¹³ä´úÂë£¬Íê³É±¾¹ØÈÎÎñ
    /********** Begin *********/
    int j=1;int i=0;next[1]=0;
    while(j&lt;=t[0])&#123;
        if(i==0||t[j]==t[i])&#123;
            i++;j++;
            next[j]=i;
        &#125;else&#123;
            i=next[i];
        &#125;
    &#125;
    /********** End   *********/
&#125;
</code></pre>
]]></content>
      <categories>
        <category>头歌</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的减法A-B</title>
    <url>/2021/11/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%8F%E6%B3%95A-B/</url>
    <content><![CDATA[<h1 id="A-B"><a href="#A-B" class="headerlink" title="A-B"></a>A-B</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>前几天是半期考试，没错我这个学校有半期考试。因为我学的比较烂，所以复习花了好多时间，没有时间更新博客，以后我尽量做到日更，谢谢大家的支持。</p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>本题要求你计算<em>A</em>−<em>B</em>。不过麻烦的是，<em>A</em>和<em>B</em>都是字符串 —— 即从字符串<em>A</em>中把字符串<em>B</em>所包含的字符全删掉，剩下的字符组成的就是字符串<em>A</em>−<em>B</em>。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在2行中先后给出字符串<em>A</em>和<em>B</em>。两字符串的长度都不超过104，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中打印出<em>A</em>−<em>B</em>的结果字符串。</p>
<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><pre><code class="in">I love GPLT!  It&#39;s a fun game!
aeiou
结尾无空行！
</code></pre>
<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><pre><code class="out">I lv GPLT!  It&#39;s  fn gm!
结尾无空行！
</code></pre>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这题的解法非常多，最简单的就是暴力写法了，对主串A的每一个字符做循环遍历模式串B中的字符，看是否相等，相等就不输出。但暴力解法的时间复杂度为N*N，而N的值可能很大，而这题的时间限制是在140ms内跑完，很有因为可能超时而不过，所以我们需要换一个办法。<br><strong>这里我用的是空间换时间的思想，我们另外开辟一个Boolean类型的一维数组，大小为52，我们可以用这个数组来存储B中出现过的字符</strong>，比如B=”aB”，则只有boo[0]和bool[26]为true，其他的都为false。这样我们对于A中的字符只需要遍历一遍就可以知道是不是需要输出，true表示不输出，false表示输出，所以代码的空间复杂度只有N了。<br>但后面我发现串B中可能不止有字母，可能还要一些特殊字符，比如’!’,’ ‘,’?’，所以还需要一个字符数组来存储出现过的特殊字符，但由于特殊字符是比较少的，所以对这个数组进行遍历花不了多少时间，而且我们可以将这种情况放在判断语句的最后，这样下来，代码的时间复杂度在串很长时依然接近N，这样这道题就写出来了。</p>
<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><pre><code class="c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
//判断A的特殊字符是否在B中存在
bool judge(char a,char b[],int c)&#123;
    for(int i=0;i&lt;c;i++)&#123;
        if(a==b[i])&#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
int main()&#123;
    string a,b;//a为主串，b为模式串
    char special[100];//由于存储b中出现过的特殊字符
    int flag=0;
    bool word[52];//存储b中出现过的字母，成表
    memset(word,false,sizeof(word));//将表全置空，也就是false
    getline(cin,a);
    getline(cin,b);
    //对表进行初始化
    for(int i=0;i&lt;b.length();i++)&#123;
        if(b[i]&gt;=&#39;a&#39;&amp;&amp;b[i]&lt;=&#39;z&#39;)&#123;
            word[b[i]-&#39;a&#39;]=true;
        &#125;else if(b[i]&gt;=&#39;A&#39;&amp;&amp;b[i]&lt;=&#39;Z&#39;)&#123;
            word[b[i]-&#39;A&#39;+26]=true;
        &#125;else&#123;
            special[flag]=b[i];
            flag++;
        &#125;
    &#125;
    //对a进行遍历，并对表进行随机查找
    for(int i=0;i&lt;a.length();i++)&#123;
        if(a[i]&gt;=&#39;a&#39;&amp;&amp;a[i]&lt;=&#39;z&#39;)&#123;
            if(!word[a[i]-&#39;a&#39;])&#123;
                cout&lt;&lt;a[i];
            &#125;
        &#125;else if(a[i]&gt;=&#39;A&#39;&amp;&amp;a[i]&lt;=&#39;Z&#39;)&#123;
            if(!word[a[i]-&#39;A&#39;+26])&#123;
                cout&lt;&lt;a[i];
            &#125;
        &#125;else&#123;
            if(judge(a[i],special,flag))&#123;//判断是否是b中的特殊字符
                cout&lt;&lt;a[i];
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>easy</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/11/08/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="琪露诺的排序"><a href="#琪露诺的排序" class="headerlink" title="琪露诺的排序"></a>琪露诺的排序</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>依旧是OJ上的门槛题，当作复习用。这题主要考察的是排序里面的归并排序。</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>笨蛋琪露诺喜欢用冰块搭积木。这天她用她的能力制造了N根冰柱作为材料，但这些冰柱显得参差不齐，不过好在她知道这些冰柱的高度。患有强迫症的小妖精琪露诺决定将这N根冰柱从小到大排列，不幸的是，琪露诺是个笨蛋，她只能将相邻的两根冰柱调换位置。现在她想知道她最少需要进行几次调换才能使这些冰柱变得有序。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入共两行。<br>第一行N(0&lt;N&lt;=500000)，代表冰柱的个数。<br>第二行N个数，代表每根冰柱的高度hi(0&lt;hi&lt;2^32)</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>一个整数，代表琪露诺最少的调换次数。</p>
<h2 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1"></a>Sample Input 1</h2><pre><code class="c++">4
4 3 2 1
</code></pre>
<h2 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1"></a>Sample Output 1</h2><pre><code class="C++">6
</code></pre>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>为什么前面说这题一定要用归并排序呢，因为如果你不这样，<strong>用别的方法，比如冒泡排序什么什么的，你会发现超时了，因为他们的时间复杂度都是O(n2),而归并排序的时间复杂度只有O(N*log2N) 且非常稳定。</strong>这题的解法只需要在归并排序的基础代码上改一些就行了，这里先解释归并排序是怎么实现的。</p>
<h3 id="归并排序分为两步："><a href="#归并排序分为两步：" class="headerlink" title="归并排序分为两步："></a>归并排序分为两步：</h3><h4 id="1-分"><a href="#1-分" class="headerlink" title="1.分"></a>1.分</h4><p>(1)我们会得到一个长为N的数组，起始位置为low，末位置为high。<br>(2)判断low是否对于high。<br>(3)是则退出。<br>(4)否则令mid为low和high的中点，递归调用“分”函数，mid分别作为两个函数的末位置和起始位置。<br>(5)即为继续第一步</p>
<h4 id="2-并"><a href="#2-并" class="headerlink" title="2.并"></a>2.并</h4><p><strong>每次分完之后都会并一次，顺序自定义，由于分是递归调用的，所以先合并的是两个长度为1的数组，而后就是两长度为2的数组合并，直到数组对半合并</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/QshuRyaoF/MyPictureBed@master/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg" alt="归并排序"></p>
<h3 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h3><p>为了完成这道题目的要求仅仅这样还是不行的，我们需要一点小改动，我们需要改进的地方只有计算逆序对的方法，有上面概念可知，在并这个过程这，两个数组都是有序的，所以<strong>当第一个序列的第x个数比第二个序列的第y个数大时，就产生了N-x+1个逆序对，这在排序过程中就可以进行统计。</strong></p>
<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><pre><code class="c++">#include&lt;iostream&gt;
using namespace std;
long long int sum=0;
//并函数
void merge(long long int a[],long long int b[],int low,int mid,int high)&#123;
    int i=low,j=mid+1,k=low;
    while(i&lt;=mid&amp;&amp;j&lt;=high)&#123;
        if(a[i]&lt;=a[j])&#123;
            b[k++]=a[i++];
        &#125;else&#123;
            b[k++]=a[j++];
            sum+=mid-i+1;
        &#125;
    &#125;
    while(i&lt;=mid)&#123;
        b[k++]=a[i++];
    &#125;
    while(j&lt;=high)&#123;
        b[k++]=a[j++];
    &#125;
    for(int i=low;i&lt;=high;i++)&#123;
        a[i]=b[i];
    &#125;
&#125;
//分函数
void msort(long long int a[],long long int b[],int low,int high)&#123;
    if(low==high)&#123;
        b[low]=a[low];
    &#125;else&#123;
        int mid=(low+high)/2;
        msort(a,b,low,mid);
        msort(a,b,mid+1,high);
        merge(a,b,low,mid,high);
    &#125;
&#125;
int  main()&#123;
    int n;
    cin&gt;&gt;n;
    long long int a[n],b[n];
    for(int i=0;i&lt;n;i++)&#123;
        cin&gt;&gt;a[i];
    &#125;
    msort(a,b,0,n-1);
    cout&lt;&lt;sum;
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>common</tag>
      </tags>
  </entry>
  <entry>
    <title>评论区已开启</title>
    <url>/2021/10/31/%E8%AF%84%E8%AE%BA%E5%8C%BA/</url>
    <content><![CDATA[<h4 id="评论区已经开始试运行，由于没有通知功能，所以我并不能及时的知道你们的评论，而我又很难有空去翻每一篇文章的评论区，看是否有新的问题，所以希望有问题的评论完后可以QQ和我说一下，谢谢。"><a href="#评论区已经开始试运行，由于没有通知功能，所以我并不能及时的知道你们的评论，而我又很难有空去翻每一篇文章的评论区，看是否有新的问题，所以希望有问题的评论完后可以QQ和我说一下，谢谢。" class="headerlink" title="评论区已经开始试运行，由于没有通知功能，所以我并不能及时的知道你们的评论，而我又很难有空去翻每一篇文章的评论区，看是否有新的问题，所以希望有问题的评论完后可以QQ和我说一下，谢谢。"></a>评论区已经开始试运行，由于没有通知功能，所以我并不能及时的知道你们的评论，而我又很难有空去翻每一篇文章的评论区，看是否有新的问题，所以希望有问题的评论完后可以QQ和我说一下，谢谢。</h4>]]></content>
      <categories>
        <category>通知</category>
      </categories>
      <tags>
        <tag>notice</tag>
      </tags>
  </entry>
  <entry>
    <title>汉英词典</title>
    <url>/2021/10/29/%E6%B1%89%E8%8B%B1%E8%AF%8D%E5%85%B8/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>我的大一下学期实训项目是好记星移动词典，基本功能是已知中文找英文，已知英文找中文，还要词典词条的增删查改，由于前俩天我就实现了这些功能，于是在之后我又增添了一个登录系统，虽然好像用处不大，但也还是我第一次写这种多文件互动的项目，写的比较用心，下面将附上项目源代码，和文件下载地址(文件是公开在本人的Github上的，有需要的可以随时取用,<strong>其中有7个文件，只要全都下载时，项目才能正常运行，且项目是通过main.c启动的</strong>)。</p>
<h3 id="文件链接-https-github-com-QshuRyaoF-ECdicttionary-tree-main-Dictionary"><a href="#文件链接-https-github-com-QshuRyaoF-ECdicttionary-tree-main-Dictionary" class="headerlink" title="文件链接:https://github.com/QshuRyaoF/ECdicttionary/tree/main/Dictionary"></a>文件链接:<a href="https://github.com/QshuRyaoF/ECdicttionary/tree/main/Dictionary">https://github.com/QshuRyaoF/ECdicttionary/tree/main/Dictionary</a></h3><h3 id="运行效果图："><a href="#运行效果图：" class="headerlink" title="运行效果图："></a>运行效果图：</h3><p><img src="https://cdn.jsdelivr.net/gh/QshuRyaoF/MyPictureBed@master/img/image-20211029005243741.png" alt="image-20211029005243741"></p>
<h3 id="Main-c"><a href="#Main-c" class="headerlink" title="Main.c"></a>Main.c</h3><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;function.h&quot;
#include &quot;dictionary.c&quot;  


int main(int argc,char **argv)
&#123;
    printf(&quot;\033[;36;5m ******************************************** \033[0m\n&quot;);
    printf(&quot;\033[;36;5m *               电子词典项目               * \033[0m\n&quot;);
    printf(&quot;\033[;36;5m ******************************************** \033[0m\n&quot;);
    printf(&quot;\033[;36;5m *     1. 注册     2. 登录     3. 退出      * \033[0m\n&quot;);
    printf(&quot;\033[;36;5m ******************************************** \033[0m\n&quot;);
    int choice,flag;
    char FILENAME[20]=&quot;user.txt&quot;;
    read(user,&amp;numofuser,FILENAME);
    printf(&quot;请输入：&quot;);
    scanf(&quot;%d&quot;,&amp;choice);
    switch (choice)
    &#123;
    case 1:sign_in(&amp;numofuser,FILENAME,user);
        break;
    case 2:login(&amp;numofuser,user);
        break;
    case 3:printf(&quot;\033[;31;5m   即将退出，欢迎您再次使用！  \033[0m\n&quot;);
        break;
    default:printf(&quot;\033[;31;5m   输入错误，请重新输入！！！  \033[0m\n&quot;);
        break;
    &#125;

    return 0;
&#125;

//统计函数
void read(struct userlist user[],int *numofuser,char filename[])&#123;
    FILE *fp;
    fp=fopen(filename,&quot;r&quot;);
    if(fp!=NULL)&#123;
        while(!feof(fp))&#123;
            fscanf(fp,&quot;%s %s %d&quot;,&amp;user[*numofuser].name,&amp;user[*numofuser].pwd,&amp;user[*numofuser].numofmemwd);
            (*numofuser)++;
        &#125;
    &#125;else&#123;
        printf(&quot;\033[;31;5m文件读取失败！！！ \033[0m\n&quot;);
    &#125;
    fclose(fp);
&#125;

//注册函数
void sign_in(int *numofuser,char filename[],struct userlist user[])&#123;
    char keyn[10],keyp1[20],keyp2[20];
    printf(&quot;用户名：&quot;);
    scanf(&quot;%s&quot;,&amp;keyn);
    for(int i=0;i&lt;*numofuser;i++)&#123;
        if(strcmp(user[i].name,keyn)==0)&#123;
            printf(&quot;\033[;31;5m    该用户已经注册,请登录！\033[0m\n&quot;);
            sign_in(&amp;(*numofuser),filename,user);
            return;
        &#125;
    &#125;
    printf(&quot;密  码：&quot;);
    int i = 0;
    char c;
    while (1)
    &#123;
        //getch()这个函数是一个不回显函数，当用户按下某个字符时，函数自动读取，无需按回车
        //函数用途：从控制台读取一个字符，但不显示在屏幕上
        c = getch();
        //如果按下Esc键可以退出
        if((c-48) == (-21))&#123;
            printf(&quot;\n\033[;31;1m      退出成功！     \033[0m\n&quot;);
                return;
        &#125;
        //windows平台下按下回车（ENTER）键会产生两个转义字符 \r\n，因此getch返回13(\r)，
        //                而&#39;\n‘的的转义字符无法读取，因此无法通过判断&#39;\n&#39;的方式结束输入，
        //可以通过读取第一个转义字符进行判断结束输入
        if (c == &#39;\r&#39;)//按下回车键时结束输入，退出
        &#123;
            keyp1[i] = &#39;\0&#39;;
            break;
        &#125;
        if (c == &#39;\b&#39;)//遇到退格键时（←Backsapce)
        &#123;
            //当没有输入密码时，即输入的密码为空时，不进行任何操作
            //即输入的密码不为空时，对显示的字符进行退格
            if (i &gt; 0) 
            &#123; 
                i--;
                //对显示的字符进行退格，两个\b之间存在一个空格
                printf(&quot;\b \b&quot;);
                        
                keyp1[i] = &#39;\0&#39;;//修改输入的字符
                continue;
            &#125;
        &#125;
        else//没有遇到回车键时和退格键时，读取输入的密码存储在字符串password中
        &#123;
            printf(&quot;*&quot;);    //对输入的密码在控制台显示*号
            keyp1[i] = c;//存储输入的字符        
            if (i &lt; 20) i++;
            else break;
        &#125;
    &#125;
    printf(&quot;\n&quot;);
    if (i &gt; 0) ;
    else  printf(&quot;输入的密码为空&quot;);
    printf(&quot;请确认密码&quot;);
    int j = 0;
    char d;
    while (1)
    &#123;
        d = getch();
        if((d-48) == (-21))&#123;
            printf(&quot;\n\033[;31;1m      退出成功！     \033[0m\n&quot;);
            return;
        &#125;
        if (d == &#39;\r&#39;)
        &#123;
            keyp2[j] = &#39;\0&#39;;
            break;
        &#125;
        if (d == &#39;\b&#39;)
        &#123;
            if (j &gt; 0) 
            &#123; 
                j--;
                printf(&quot;\b \b&quot;);    
                keyp2[j] = &#39;\0&#39;;
                continue;
            &#125;
        &#125;
        else
        &#123;
            printf(&quot;*&quot;);
            keyp2[j] = d;    
            if (j &lt; 20) j++;
            else break;
        &#125;
    &#125;
     
    printf(&quot;\n&quot;);
    if (j &gt; 0) ;
    else  printf(&quot;输入的密码为空&quot;);
    if(strcmp(keyp1,keyp2)!=0)&#123;
        printf(&quot;\033[;31;5m   两次输入密码不一致，请重新输入! \033[0m\n&quot;);
        sign_in(&amp;(*numofuser),filename,user);
    &#125;
    int flag=0;   
    strcpy(user[*numofuser].name,keyn);
    strcpy(user[*numofuser].pwd,keyp1);
    user[*numofuser].numofmemwd=0;
    (*numofuser)++;
    FILE *fp;
    fp=fopen(filename,&quot;w&quot;);
    if(fp!=NULL)&#123;
        for(int k=0;k&lt;(*numofuser)-1;k++)&#123;
            fprintf(fp,&quot;%s %s %d\n&quot;,user[k].name,user[k].pwd,user[k].numofmemwd);
        &#125;
        fprintf(fp,&quot;%s %s %d&quot;,user[*numofuser-1].name,user[*numofuser-1].pwd,user[*numofuser-1].numofmemwd);
    &#125;else&#123;
        printf(&quot;文件打开失败\n&quot;);
    &#125;
    fclose(fp);
    printf(&quot;\n\033[;31;5m      %s,恭喜您，注册成功\033[0m\n&quot;,keyn);
    printf(&quot;请重新登录！\n&quot;);
    login(&amp;(*numofuser),user);
    flag=1;      
    if(flag==0)&#123;
        printf(&quot;\033[;31;5m注册失败!!!\033[0m\n&quot;);
    &#125;
&#125;

//登录函数
void login(int *numofuser,struct userlist user[])&#123;
    char keyn[10],keyp[20];
    while(1)&#123;
        printf(&quot;用户名：&quot;);
        scanf(&quot;%s&quot;,keyn);
        printf(&quot;密  码：&quot;);
        int i = 0,flag=0;
        char c;
        while (1)
        &#123;
            c = getch();
            if((c-48) == (-21))&#123;
                printf(&quot;\n\033[;31;1m      退出成功！     \033[0m\n&quot;);
                return;
            &#125;
            if (c == &#39;\r&#39;)
            &#123;
                keyp[i] = &#39;\0&#39;;
                break;
            &#125;
            if (c == &#39;\b&#39;)
            &#123;
                if (i &gt; 0) 
                &#123; 
                    i--;
                    printf(&quot;\b \b&quot;);    
                    keyp[i] = &#39;\0&#39;;
                    continue;
                &#125;
            &#125;
            else
            &#123;
                printf(&quot;*&quot;);
                keyp[i] = c;    
                if (i &lt; 20) i++;
                else break;
            &#125;
        &#125;
        printf(&quot;\n&quot;);
        if (i &gt; 0) ;
        else  printf(&quot;输入的密码为空&quot;);
        for(int i=0;i&lt;*numofuser;i++)&#123;
            if(strcmp(keyn,user[i].name)==0&amp;&amp;strcmp(keyp,user[i].pwd)==0)&#123;
                printf(&quot;\n\033[;31;1m      %s,恭喜您，登录成功! \033[0m\n&quot;,keyn);
                flag=1;
                fakemain(user[i].name);
                return;
            &#125;
        &#125;
        if(flag==0)&#123;
            printf(&quot;\033[;31;5m     用户名或密码错误，请重新输入!!! \033[0m\n&quot;);
        
        &#125;
    &#125; 
&#125;
</code></pre>
<h3 id="dictionary-c"><a href="#dictionary-c" class="headerlink" title="dictionary.c"></a>dictionary.c</h3><pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;function.h&quot;

//本文件的主函数
void fakemain(char name[])
&#123;
    struct entry ent[10000];
    int numofwords = 0, choose;
    char FILEPATH[30] = &quot;new_dictionary.txt&quot;;
    search(FILEPATH, ent, &amp;numofwords);
    UI(&amp;numofwords, ent, FILEPATH, &amp;choose, name);
    return;
&#125;

//查询有多少个词条的功能函数
void search(char filepath[], struct entry ent[], int *numofwords)
&#123;
    FILE *fp;
    fp = fopen(filepath, &quot;a+&quot;);
    if (fp != NULL)
    &#123;
        while (!feof(fp))
        &#123;
            fscanf(fp, &quot;%s %s&quot;, &amp;ent[*numofwords].english, &amp;ent[*numofwords].chinese);
            (*numofwords)++;
        &#125;
    &#125;
    else
    &#123;
        printf(&quot;\033[;31;5m文件读取失败！！！ \033[0m\n&quot;);
    &#125;
    fclose(fp);
&#125;

//英译汉功能函数
void E2C(int *numofwords, struct entry ent[])
&#123;
    char key[20];
    while (1)
    &#123;
        printf(&quot;请输入要查询的词(输入0000退出查询)：&quot;);
        scanf(&quot;%s&quot;, key);
        if (strcmp(key, &quot;0000&quot;) == 0)
        &#123;
            return;
        &#125;
        int flag = 0;
        for (int i = 0; i &lt; *numofwords; i++)
        &#123;
            if (strcmp(key, ent[i].english) == 0)
            &#123;
                printf(&quot;\033[;33;5m\&quot;%s\&quot; 的中文释义为：%s\033[0m\n&quot;, ent[i].english, ent[i].chinese);
                flag = 1;
                break;
            &#125;
        &#125;
        if (flag == 0)
        &#123;
            printf(&quot;\033[;31;5m查无此词!!!\033[0m\n&quot;);
        &#125;
    &#125;
&#125;

//汉译英功能函数
void C2E(int *numofwords, struct entry ent[])
&#123;
    char key[20];
    while (1)
    &#123;
        printf(&quot;请输入要查询的词(输入0000退出查询):&quot;);
        scanf(&quot;%s&quot;, key);
        if (strcmp(key, &quot;0000&quot;) == 0)
        &#123;
            return;
        &#125;
        int flag = 0;
        for (int i = 0; i &lt; *numofwords; i++)
        &#123;
            if (strstr(ent[i].chinese, key) != NULL)
            &#123;
                printf(&quot;\033[;33;5m\&quot;%s\&quot; 对应的英文是：\&quot;%s\&quot;\033[0m\n&quot;, ent[i].chinese, ent[i].english);
                flag++;
            &#125;
        &#125;
        if (flag == 0)
        &#123;
            printf(&quot;\033[;31;5m查无此词!!!\033[0m\n&quot;);
        &#125;
    &#125;
&#125;

//删除词条功能函数
void deleteentry(int *numofwords, struct entry ent[], char filepath[])
&#123;
    char key[20];
    printf(&quot;请输入要删去的词(输入0000退出删除):&quot;);
    scanf(&quot;%s&quot;, key);
    if (strcmp(key, &quot;0000&quot;) == 0)
    &#123;
        return;
    &#125;
    int flag = 0;
    for (int i = 0; i &lt; *numofwords; i++)
    &#123;
        if (strcmp(key, ent[i].english) == 0)
        &#123;
            for (int j = i; j &lt; (*numofwords) - 1; j++)
            &#123;
                ent[j] = ent[j + 1];
            &#125;
            (*numofwords)--;
            FILE *fp;
            fp = fopen(filepath, &quot;w+&quot;);
            if (fp != NULL)
            &#123;
                for (int k = 0; k &lt; (*numofwords) - 1; k++)
                &#123;
                    fprintf(fp, &quot;%s %s\n&quot;, ent[k].english, ent[k].chinese);
                &#125;
                fprintf(fp, &quot;%s %s&quot;, ent[*numofwords].english, ent[*numofwords].chinese);
                printf(&quot;\033[;33;5m词条删除成功!\033[0m\n&quot;);
            &#125;
            else
            &#123;
                printf(&quot;文件读取失败\n&quot;);
            &#125;
            fclose(fp);
            flag = 1;
            break;
        &#125;
    &#125;
    if (flag == 0)
    &#123;
        printf(&quot;\033[;31;5m查无此词!!!\033[0m\n&quot;);
    &#125;
&#125;

//用户操作界面
void UI(int *numofwords, struct entry ent[], char filepath[], int *choose, char name[])
&#123;
    /*操作界面*/
    printf(&quot;\n\033[;33;5m*************************************************\033[0m\n&quot;);
    printf(&quot;\033[;33;5m*                欢迎使用电子词典               *\033[0m\n&quot;);
    printf(&quot;\033[;33;5m*************************************************\033[0m\n&quot;);
    printf(&quot;\033[;33;5m*     1.英译汉      2.汉译英     3.删除词条     *\033[0m\n&quot;);
    printf(&quot;\033[;33;5m*     4.添加词条    5.修改词条   6.背单词       *\033[0m\n&quot;);
    printf(&quot;\033[;33;5m*               7. 保 存 并 退 出               *\033[0m\n&quot;);
    printf(&quot;\033[;33;5m*************************************************\033[0m\n&quot;);
    printf(&quot;\033[;33;5m当前字典一共用%d个单词\033[0m\n&quot;, *numofwords);

    //用户输入选择
    printf(&quot;请输入：&quot;);
    scanf(&quot;%d&quot;, &amp;(*choose));
    switch (*choose)
    &#123;
    case 1:
        E2C(&amp;(*numofwords), ent);
        UI(&amp;(*numofwords), ent, filepath, &amp;(*choose), name);
        break;
    case 2:
        C2E(&amp;(*numofwords), ent);
        UI(&amp;(*numofwords), ent, filepath, &amp;(*choose), name);
        break;
    case 3:
        deleteentry(&amp;(*numofwords), ent, filepath);
        UI(&amp;(*numofwords), ent, filepath, &amp;(*choose), name);
        break;
    case 4:
        addentry(&amp;(*numofwords), ent, filepath);
        UI(&amp;(*numofwords), ent, filepath, &amp;(*choose), name);
        break;
    case 5:
        modientry(&amp;(*numofwords), ent, filepath);
        UI(&amp;(*numofwords), ent, filepath, &amp;(*choose), name);
        break;
    case 6:reciteword(name,user,ent,&amp;numofuser);
        UI(&amp;(*numofwords), ent, filepath, &amp;(*choose), name);
        break;
    case 7:printf(&quot;\033[;31;5m        保存成功,欢迎再次使用!\033[0m\n&quot;);
        break;
    default:
        printf(&quot;\033[;31;5m输入错误，请重新输入!!!\033[0m\n&quot;);
        UI(&amp;(*numofwords), ent, filepath, &amp;(*choose), name);
        break;
    &#125;
    return;
&#125;

//添加词条功能函数
void addentry(int *numofwords, struct entry ent[], char filepath[])
&#123;
    char keye[20], keyc[20];
    printf(&quot;请输入要添加的单词(输入0000退出添加):&quot;);
    scanf(&quot;%s&quot;, &amp;keye);
    if (strcmp(keye, &quot;0000&quot;) == 0)
    &#123;
        return;
    &#125;
    for (int i = 0; i &lt; *numofwords; i++)
    &#123;
        if (strcmp(ent[i].english, keye) == 0)
        &#123;
            printf(&quot;该词已在单词库中！\n&quot;);
            return;
        &#125;
    &#125;
    printf(&quot;请输入中文释义:&quot;);
    scanf(&quot;%s&quot;, &amp;keyc);
    int flag = 0, tmp;
    for (int i = 0; i &lt; *numofwords; i++)
    &#123;
        if (strcmp(keye, ent[i].english) &gt; 0)
        &#123;
            tmp = i;
        &#125;
        else
        &#123;
            break;
        &#125;
    &#125;
    for (int j = *numofwords - 1; j &gt; tmp; j--)
    &#123;
        ent[j + 1] = ent[j];
    &#125;
    strcpy(ent[tmp + 1].english,keye);
    strcpy(ent[tmp + 1].chinese,keyc);
    (*numofwords)++;
    FILE *fp;
    fp = fopen(filepath, &quot;w&quot;);
    if (fp != NULL)
    &#123;
        for (int k = 0; k &lt; (*numofwords) - 1; k++)
        &#123;
            fprintf(fp, &quot;%s %s\n&quot;, ent[k].english, ent[k].chinese);
        &#125;
        fprintf(fp, &quot;%s %s&quot;, ent[*numofwords - 1].english, ent[*numofwords - 1].chinese);
    &#125;
    else
    &#123;
        printf(&quot;文件打开失败\n&quot;);
    &#125;
    fclose(fp);
    printf(&quot;\033[;33;5m添加成功！！！\033[0m\n&quot;);
    flag = 1;
    if (flag == 0)
    &#123;
        printf(&quot;添加失败!!!\n&quot;);
    &#125;
&#125;

//修改词条功能函数
void modientry(int *numofwords, struct entry ent[], char filepath[])
&#123;
    char key[20], keye[20], keyc[20];
    FILE *fp;
    int flag = 0, tmp;
    do
    &#123;
        printf(&quot;请输入要修改的单词(退出修改请输入0000):&quot;);
        scanf(&quot;%s&quot;, key);
        if (strcmp(key, &quot;0000&quot;) == 0)
        &#123;
            return;
        &#125;
        for (int i = 0; i &lt; *numofwords; i++)
        &#123;
            if (strcmp(key, ent[i].english) == 0)
            &#123;
                flag = 1;
                for (int j = i; j &lt; (*numofwords) - 1; j++)
                &#123;
                    ent[j] = ent[j + 1];
                &#125;
                (*numofwords)--;
                FILE *fp;
                fp = fopen(filepath, &quot;w&quot;);
                if (fp != NULL)
                &#123;
                    for (int k = 0; k &lt; (*numofwords) - 1; k++)
                    &#123;
                        fprintf(fp, &quot;%s %s\n&quot;, ent[k].english, ent[k].chinese);
                    &#125;
                    fprintf(fp, &quot;%s %s&quot;, ent[*numofwords].english, ent[*numofwords].chinese);
                    break;
                &#125;
            &#125;
        &#125;
        if (flag == 0)
        &#123;
            printf(&quot;\033[;31;5m查无此词！！！\033[0m\n&quot;);
        &#125;
    &#125; while (!flag);
    printf(&quot;请输入修改后的英文和中文(其间请用空格或换行隔开):\n&quot;);
    scanf(&quot;%s&quot;, keye);
    scanf(&quot;%s&quot;, keyc);
    for (int i = 0; i &lt; *numofwords; i++)
    &#123;
        if (strcmp(ent[i].english, keye) == 0)
        &#123;
            printf(&quot;\033[;31;5m该词已在单词库中！\033[0m\n&quot;);
            return;
        &#125;
    &#125;
    for (int i = 0; i &lt; *numofwords; i++)
    &#123;
        if (strcmp(keye, ent[i].english) &gt; 0)
        &#123;
            tmp = i;
        &#125;
        else
        &#123;
            break;
        &#125;
    &#125;
    for (int j = *numofwords - 1; j &gt; tmp; j--)
    &#123;
        ent[j + 1] = ent[j];
    &#125;
    strcpy(ent[tmp + 1].english, keye);
    strcpy(ent[tmp + 1].chinese, keyc);
    (*numofwords)++;
    fp = fopen(filepath, &quot;w&quot;);
    if (fp != NULL)
    &#123;
        for (int k = 0; k &lt; (*numofwords) - 1; k++)
        &#123;
            fprintf(fp, &quot;%s %s\n&quot;, ent[k].english, ent[k].chinese);
        &#125;
        fprintf(fp, &quot;%s %s&quot;, ent[*numofwords - 1].english, ent[*numofwords - 1].chinese);
        printf(&quot;\033[;33;5m修改完成!\033[0m\n&quot;);
    &#125;
    else
    &#123;
        printf(&quot;文件打开失败\n&quot;);
        return;
    &#125;
    fclose(fp);
&#125;

//背单词功能函数
void reciteword(char name[],struct userlist user[],struct entry ent[],int *numofuser)
&#123;
    int n, choice, station, m;
    FILE *fp;
    for (int i = 0; i &lt; *numofuser; i++)
    &#123;
        if (strcmp(user[i].name, name) == 0)
        &#123;
            station = user[i].numofmemwd;
            m = i;
            printf(&quot;\033[;35;5m     您已经背了%d个单词了，继续加油哦~(&#39;.&#39;)~\033[0m\n&quot;, user[i].numofmemwd);
        &#125;
    &#125;
    printf(&quot;\n\033[;34;5m*************************************\033[0m\n&quot;);
    printf(&quot;\033[;34;5m*      1.背新单词    2.复习单词     *\033[0m\n&quot;);
    printf(&quot;\033[;34;5m*************************************\033[0m\n&quot;);
    printf(&quot;请输入：&quot;);
    scanf(&quot;%d&quot;, &amp;choice);
    switch (choice)
    &#123;
        case 1:
        &#123;
            printf(&quot;请输入这次要背的单词数：&quot;);
            scanf(&quot;%d&quot;, &amp;n);
            for (int i = 0; i &lt; n; i++)
            &#123;
                printf(&quot;\033[;33;5m   %s %s\033[0m\n&quot;, ent[station + i].english, ent[station + i].chinese);
            &#125;
            printf(&quot;\033[;33;5m你是最棒的！~(&#39;o&#39;)~\033[0m\n&quot;);
            user[m].numofmemwd += n;
            fp = fopen(&quot;user.txt&quot;, &quot;w&quot;);
            if (fp != NULL)
            &#123;
                for (int k = 0; k &lt; (*numofuser)-1; k++)
                &#123;
                    fprintf(fp, &quot;%s %s %d\n&quot;, user[k].name, user[k].pwd, user[k].numofmemwd);
                &#125;
                fprintf(fp, &quot;%s %s %d&quot;, user[*numofuser - 1].name, user[*numofuser - 1].pwd, user[*numofuser - 1].numofmemwd);
            &#125;
                else
            &#123;
                printf(&quot;\033[;31;5m文件读取失败！！！ \033[0m\n&quot;);
            &#125;   
            fclose(fp);
        &#125;
            break;
        case 2:
        &#123;
            printf(&quot;请输入这次要复习的单词数：&quot;);
            scanf(&quot;%d&quot;, &amp;n);
            for (int i = 0; i &lt; n; i++)
            &#123;
                printf(&quot;\033[;33;5m   %s %s\033[0m\n&quot;, ent[station - i - 1].english, ent[station - i - 1].chinese);
            &#125;
            printf(&quot;\033[;33;5m你是最棒的！~(&#39;o&#39;)~\033[0m\n&quot;);
        &#125;
            break;
        default:printf(&quot;\033[;31;5m输入错误，请重新输入!!!\033[0m\n&quot;);
            reciteword(name,user,ent,&amp;(*numofuser));
            break;
    &#125;

&#125;
</code></pre>
<h3 id="function-h"><a href="#function-h" class="headerlink" title="function.h"></a>function.h</h3><pre><code class="c">#include&lt;stdio.h&gt; 
#ifndef function_h

#define function_h

#define MAXC 20
#define MAXE 20
#define total 10000

struct entry
&#123;
    char english[MAXE+1]; //key 
    char chinese[MAXC+1];
    struct entry *next;
&#125;;
struct userlist
&#123;
    char name[10];
    char pwd[20];
    int numofmemwd;
&#125;;

struct userlist user[1000];
int numofuser=0;

/*函数声明*/
void search(char filepath[],struct entry ent[],int *numofwords);
void E2C(int *numofwords,struct entry ent[]);
void C2E(int *numofwords,struct entry ent[]);
void deleteentry(int *numofwords,struct entry ent[],char filepath[]);
void UI(int *numofwords,struct entry ent[],char filepath[],int *choose,char name[]);
void addentry(int *numofwords,struct entry ent[],char filepath[]);
void modientry(int *numofwords,struct entry ent[],char filepath[]);
void fakemain(char name[]);
void read(struct userlist user[],int *numofuser,char filename[]);
void sign_in(int *numofuser,char filename[],struct userlist user[]);
void login(int *numofuser,struct userlist user[]);
void reciteword(char name[],struct userlist user[],struct entry ent[],int *numofuser);

#endif
</code></pre>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>difficult</tag>
      </tags>
  </entry>
</search>
